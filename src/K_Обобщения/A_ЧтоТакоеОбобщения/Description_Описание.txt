Обобщения - это параметризованные типы. Такие типы позволяют объявлять классы, интерфейсы и методы,
где тип данных, которыми они оперируют, указан в виде параметра. Используя обобщения, можно, например,
создать единственный класс, который будет автоматически обращаться с разнотипными данными.
Классы, интерфейсы или методы, оперирующие параметризованными типами, называются обобщенными.

Благодаря обобщениям все операции приведения типов выполняются автоматически и неявно.
Таким образом, обобщения расширили возможности повторного использования кода, позволив делать это легко
и безопасно.

Обратите внимание на объявление класса Gen из примера "Простой обобщенный класс" в следующей строке кода:
class Gen<T> {
}
Здесь T обозначает имя параметра типа. Это имя используется в качестве заполнителя, вместо которого
в дальнейшем подставляется имя конкретного типа, передаваемого классу Gen при создании объекта.
Это означает, что обозначение T применяется в классе Gen всякий раз, когда требуется параметр типа.
Обратите внимание на то, что обозначение Т заключено в угловые скобки ( < > ).
Этот синтаксис может быть обобщен. Всякий раз, когда объявляется параметр типа, он указывается в угловых скобках.
В классе Gen применяется параметр типа, и поэтому он является обобщенным классом,
относящимся к так называемому параметризованному типу.

Далее тип Т используется для объявления объекта оb:
T оb; //объявить объект типа T
Параметр типа Т - это место для подстановки конкретного типа, который указывается в дальнейшем при создании
объекта класса Gen. Это означает, что объект оb станет объектом того типа, который будет передан в качестве
параметра типа T. Так, если передать тип String в качестве параметра типа Т, то такой экземпляр объекта оb
будет иметь тип String.

Рассмотрим конструктор Gen().
Gen (T o) {
   ob = o;
}

Параметр o имеет тип T. Это означает, что конкретный тип параметра о определяется с помощью параметра типа Т,
передаваемого при создании объекта класса Gen. А поскольку параметр о и переменная экземпляра оЬ относятся к типу T,
то они получают одинаковый конкретный тип при создании объекта класса Gen. Параметр типа Т может быть также
использован для указания типа, возвращаемого методом, как показано ниже на примере метода getob().
Объект оb также относится к типу Т, поэтому его тип совместим с типом, возвращаемым методом getob().

T getOb() {
    return ob;
}

Метод showType() отображает тип Т, вызывая метод getName() для объекта типа Class, возвращаемого в результате
вызова метода getClass() для объекта оЬ. Метод getClass() определен в классе Object, и поэтому он является
членом всех классов. Этот метод возвращает объект типа Class, соответствующий типу того класса объекта,
для которого он вызывается. В классе Class определяется метод getName(), возвращающий строковое
представление имени класса.
    void showType() {
        System.out.println("Tипoм Т является: " + ob.getClass().getName());
    }

Класс GenDemo служит для демонстрации обобщенного класса Gen. Сначала в нем создается версия класса
Gen для целых чисел, как показано ниже.
Gen<Integer> iOb; // Создать ссылку типа Gen для целых чисел

Integer - это аргумент типа, который передается в качестве параметра типа Т из класса Gen.
Это объявление фактически означает создание версии класса Gen, где все ссылки на тип Т преобразуются
в ссылки на тип Integer. Таким образом, в данном объявлении объект оb относится к типу Integer,
и метод getob() возвращает тип Integer.

Компилятор Java на самом деле не создает разные версии класса Gen или любого другого обобщенного класса.
Вместо этого компилятор удаляет все сведения об обобщенных типах, выполняя необходимые операции приведения типов,
чтобы сделать поведение прикладного кода таким, как будто создана конкретная версия класса Gen.
Таким образом, имеется только одна версия класса Gen, которая существует в прикладной программе.
Процесс удаления обобщенной информации об обобщенных типах называется стиранием.

В следующей строке кода переменной iOb присваивается ссылка на экземпляр целочисленной версии класса Gen:
iOb = new Gen<Integer>(12345678);

Когда вызывается конструктор Gen(), аргумент типа Integer также указывается. Это необходимо потому, что объект
(в данном случае - iOb), которому присваивается ссылка, относится к типу Gen. Следовательно, ссылка,
возвращаемая операцией new, также должна относиться к типу Gen. В противном случае во время компиляции
возникает ошибка.
Например, следующее присваивание вызовет ошибку во время компиляции:
iOb = new Gen<DouЬle>(12345678.0); // ОШИБКА!!!

Переменная iOb относится к типу Gen, поэтому она не может быть использована для присваивания ссылки типа
Gen<DouЬle>. Такая проверка типа является одним из основных преимуществ обобщений, потому что она
обеспечивает типовую безопасность.

Как следует из комментариев к данной программе, в приведенной ниже операции присваивания выполняется
автоупаковка для инкапсуляции значения 12345678 типа int в объекте типа Integer.
iOb = new Gen<Integer>(12345678);

Обобщение Gen создает конструктор, принимающий аргумент типа Integer. А поскольку предполагается объект типа
Integer, то значение 12345678 автоматически упаковывается в этом объекте.
Присваивание может быть указано и явным образом, как показано ниже, но такой его вариант не дает никаких
преимуществ.
iOb = new Gen<Integer>(new Integer(12345678));

Затем в данной программе отображается тип объекта оb в переменной iOb (в данном случае - тип Integer).
А далее получается значение объекта оb в следующей строке кода:
int v = iOb.getob();

Метод getob() возвращает обобщенный тип T, который был заменен на тип Integer при объявлении переменной
экземпляра iOb. Поэтому метод getob() также возвращает тип Integer, который автоматически распаковывается
в тип int и присваивается переменной v типа int. Следовательно, тип, возвращаемый методом getob(),
не нужно приводить к типу Integer. Безусловно, выполнять автоупаковку необязательно, переписав предыдущую
строку кода так, как показано ниже. Но автоупаковка позволяет сделать код более компактным.
int v = iOb.getob().intValue();

Далее в классе GenDemo объявляется объект типа Gen следующим образом:
Gen<String> sOb = new Gen<String>("текстовая строка");

В качестве аргумента типа в данном случае указывается тип String, подставляемый вместо параметра типа Т
в обобщенном классе Gen. Это, по существу, приводит к созданию строковой версии класса Gen, что и демонстрируется
в остальной части программы.