Дело в том, что обобщения автоматически гарантируют типовую безопасность во всех операциях, где задействован
обобщенный класс Gen. В процессе его применения исключается потребность в явном приведении и ручной проверке
типов в прикладном коде.
Пример программы, в которой создается необобщенный эквивалент
класса Gen: "Продемонстрировать необобщенный класс".

В классе NonGen все ссылки на тип Т заменены ссылками на тип Object. Это позволяет хранить в классе NonGen
объекты любого типа, как и в обобщенном классе Gen. Но это не позволяет компилятору Java получить какие нибудь
подлинные сведения о типе данных, фактически сохраняемых в объекте класса NonGen, что плохо по двум причинам.
Во-первых, для извлечения сохраненных данных требуется явное приведение типов.
И во-вторых, многие ошибки несоответствия типов не могут быть обнаружены до времени выполнения.

Обратим внимание на следующую строку кода:
int v = (Integer) iOb.getob();

Метод getob() возвращает тип Object, поэтому его нужно привести к типу Integer, чтобы выполнить автораспаковку
и сохранить значение в переменной v. Если убрать приведение типов, программа не скомпилируется.
Если в ее версии с обобщениями приведение типов производится неявно, то в версии без обобщений приведение
должно быть сделано явно. Это не только неудобно, но и служит потенциальным источником ошибок.

Теперь рассмотрим следующий фрагмент кода в конце данной программы:
// Этот код компилируется, но он принципиально неверный!!!
iOb = sOb;
v = (Integer) iOb.getOb(); // Ошибка!!! во время выполнения.

Здесь переменной экземпляра iOb присваивается значение переменной экземпляра sOb. Но переменная экземпляра
sOb ссылается на объект, содержащий символьную строку, а не целое число. Такое присваивание синтаксически
корректно, потому что все ссылки типа NonGen одинаковы и любая ссылка типа NonGen может указывать на любой
другой объект типа NonGen. Но семантически эта операция присваивания неверна, что и отражено в следующей
строке коде. Здесь тип, возвращаемый методом getob(),приводится к типу Integer, а затем делается попытка
присвоить полученное значение переменной v. Дело в том, что переменная экземпляра iOb теперь ссылается на
объект, хранящий данные типа String, а не Integer.
К сожалению, без обобщений компилятор Java просто не в состоянии обнаружить эту ошибку. Вместо этого во
время выполнения генерируется исключение при попытке привести к типу Integer.

Возможность создавать типизированный (т.е. обеспечивающий типовую безопасность) код, в котором ошибки
несоответствия типов перехватываются компилятором, является главным преимуществом обобщений.

Благодаря обобщениям ошибки, возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые
во время компиляции. В этом и заключается главное преимущество обобщений.