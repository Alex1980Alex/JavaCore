До выхода JDK 7 для создания экземпляра MyClass нужно было использовать оператор вида:
MyClass<Integer, Str ing> mcOb = new MyClass<Integer, String> (98, "Строка") ;

В версии JDK 7 был внедрен синтаксический элемент, позволяющий избежать повторного указания
аргументов типа.
MyClass<lnteger, String> mcOb = new MyClass<>(99, "Строка");

Обратите внимание на то, что в правой части приведенного выше оператора, где создается экземпляр,
просто указываются угловые скобки(<>), обозначающие пустой список аргументов типа и называемые
ромбовидным оператором. Этот оператор предписывает компилятору вывести тип аргументов,
требующихся конструктору в операции new. Главное преимущество синтаксиса выведения типов
заключается в том, что он короче и иногда значительно сокращает очень длинные операторы объявления.

Когда выполняется выведение типов, синтаксис объявления для обобщенной ссылки и создания экземпляра
имеет приведенную ниже общую форму, где список аргументов типа конструктора в операции new пуст.
имя_класса<список_аргументов_типа> имя_переменной = new имя_класса<>(список_аргументов_конструктора);

Выведение типов можно также выполнять и при передаче параметров. Так, если в класс MyClass
вводится следующий метод:
boolean isSame(MyClass<T, V> о) {
   if(ob1 == о.оb1 && оb2 == о.оb2) return true;
   else return false;
}

то приведенный ниже вызов считается вполне допустимым.
if(mcOb.isSame(new MyClass<>(88, "test")))
   System.out.println("Same");

В данном случае аргументы типа для аргумента, передаваемого методу isSame(),
могут быть выведены из параметров типа.