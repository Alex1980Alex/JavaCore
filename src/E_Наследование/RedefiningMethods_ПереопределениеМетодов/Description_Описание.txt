Переопределение методов (method overriding) в Java позволяет вам предоставить
новую реализацию метода в подклассе, который был унаследован от его суперкласса.
Переопределение методов позволяет объектам класса-потомка вести себя по-разному
в сравнении с объектами класса-родителя.
Вот как это делается:
1. Сначала у вас должна быть иерархия классов, где у класса-потомка есть метод с тем же именем,
параметрами и типом возвращаемого значения, что и метод класса-родителя.
Это создает переопределение метода.
2. Используйте аннотацию @Override перед переопределенным методом для явного указания,
что вы переопределяете метод суперкласса.
Это помогает предотвратить ошибки, если вы ошибочно измените имя метода или его сигнатуру.
3. Новая реализация метода в классе-потомке должна быть помечена ключевым словом super,
чтобы вызвать реализацию метода суперкласса, если это необходимо, или выполнить другие действия, дополняя или заменяя базовую реализацию.

Пример переопределения метода:
class Animal {
    void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Собака лает");
    }

    void wagTail() {
        System.out.println("Собака виляет хвостом");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog(); // Полиморфизм - объект типа Dog, но ссылка типа Animal

        myAnimal.makeSound(); // Вывод: "Животное издает звук"
        myDog.makeSound();     // Вывод: "Собака лает"

        // Нельзя вызвать myDog.wagTail(),
        так как ссылка типа Animal не имеет доступа к методу wagTail()
    }
}

Перезагрузка методов в подклассе (subclass) в Java является одним из аспектов полиморфизма
и позволяет перегрузить методы, унаследованные от суперкласса (superclass), в подклассе.
Это означает, что вы можете определить новую версию метода в подклассе с таким же именем,
но с разными параметрами.
Когда объект подкласса вызывает этот метод, будет использоваться реализация из подкласса,
а не из суперкласса.
Пример перезагрузки методов в подклассе:
class Animal {
    void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    // Перезагруженный метод с другой сигнатурой (без параметров)
    void makeSound() {
        System.out.println("Собака лает");
    }

    // Перезагруженный метод с параметром
    void makeSound(String sound) {
        System.out.println("Собака издает звук: " + sound);
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog();

        myAnimal.makeSound(); // Вывод: "Животное издает звук"
        myDog.makeSound();    // Вывод: "Собака лает"

        // Вызываем перезагруженный метод с параметром
        ((Dog) myDog).makeSound("Гав-гав"); // Вывод: "Собака издает звук: Гав-гав"
    }
}
В этом примере класс Dog перезагружает метод makeSound из суперкласса Animal.
Он предоставляет две версии метода: одну без параметров и одну с параметром.
При вызове makeSound на объекте типа Dog,
будет вызвана соответствующая версия метода из класса Dog.

Важно отметить, что перезагрузка методов в подклассе может использоваться
для предоставления дополнительной функциональности или переопределения методов,
унаследованных от суперкласса, в зависимости от требований вашей программы.

